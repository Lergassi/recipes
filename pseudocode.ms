//----------------------------------------------------------------
// добавление/удаление позиции из рецепта
//----------------------------------------------------------------

ид рецепта = 10
ид позиции = 20

удалить позицию(ид рецепта, ид позиции)
    рецепт = бд.найти(рецепты, ид рецепта)
    если рецепт главный
        //позиция = бд.найти(позиции, ид позиции)
        бд.удалить(позиции, ид позиции)
    //или
    рецепт = бд.найти(рецепты, ид рецепта, главный)
    если рецепт
        бд.удалить(позиции, ид позиции)

ооп
класс Рецепт
    рецепт(данные)
        //...
    удалить позицию(ид позиции)
        если !можно редактировать()
            вернуть 0
        иначе
            _позиции.удалить(ид позиции)    //допустим тут доступ по ид
    можно редактировать(): bool

рецепт = Рецепт([
    42,
    Плов,
    [
        вода: 2000,
        рис: 1000,
        мясо: 1000,
        морковка: 1000,
        соль: 10,
        //...
    ]
])

рецепт.удалить(вода, 100)           //меньше воды
рецепт.добавить(черный перец, 1)    //тестируем сушеный чеснок
рецепт.добавить(сушеный чесно, 10)  //тестируем сушеный чеснок
рецепт.добавить(кориандр, 10)       //тестируем сушеный чеснок
/*
    Получается если делать всё на сервере в одном запросе от пользователя, то надо все операции фиксировать. Точнее получить все записи. Сделать действие. Затем в конце вызвать flush/update/save и выполнить:
    insert
    update
    delete

    insert если позиция новая
    delete если вес позиции <= 0
    update в остальных случаях

    Но при этом от пользователя проходит весь измененный список позиций сразу как с простой html формой + обработка в post как раньше. Что делал пользователь на клиенте не известно. Нужно просто обработать список и выполнить insert/update/create. И это не измененные данные, а полностью новые. Методы add/remove не нужны.
    Либо можно загрузить рецепт и позиции из бд на запрос пользователя. Методов add/remove не будет, а только set/update (по идеи это сеттеры). Следующая логика такая же: insert/delete/update.
*/

/*
    Вариант с api.

    Есть отдельные методы:

    добавить позицию(ид рецепта, ид продукта, вес)
    удалить позицию(ид рецепта, ид позиции)
    обновить позицию(ид рецепта, ид позиции, новый вес)

    //### вариант вообще без позиций ###
    /*
        т.е. как в игре. Программа(сервер)/класс/объект сами разберутся что делать. И никаких recipe_version_positions и кучи таблиц со связями наружу не показывается.
    */
    добавить продукт(ид рецепта, ид продукта, вес)
    удалить продукт(ид рецепта, ид продукта, вес)       //если итоговый вес <= 0 продукт полностью удаляется из рецепта
    полностью удалить продукт(ид рецепта, ид продкута)  //отдельный метод, чтобы не спутать. А в остальных обязательно нужно положительное число указывать.
    //идеи методов
    добавить продукт по весу другого продукта(ид рецепта, ид добавляемого продукта, ид имеющегося продукта, пропорция)
    обновить продукт по весу другого продукта(ид рецепта, ид требуемого продукта, ид имеющегося продукта, пропорция)
*/

//----------------------------------------------------------------
// Проверка возможности редактирования рецепта.
//----------------------------------------------------------------
Варианты.
1. Сделать отдельный запрос на поиск рецепта и обработать до позиции.
!2. Добавить в поиск позиции join, а в метод аргумент is_main/editable.
-> Неправильно. Определить наличие рецепта так невозможно.
-- Сделать метод только для поиска редактируемой позиции.
3. Класс Recipe/RecipeService, который сам решит можно ли редактировать рецепт или нет. Но при этом нужно отдельно вне класса делать связь с sql.
В 1ом варианте логика одна и может пригодиться еще в нескольких места, а в случае с джоином логику придется писать каждый раз новыю.

//----------------------------------------------------------------
// Валидация.
//----------------------------------------------------------------

данные =
    название: строка
    алиас: строка или пусто
    сорт: число или пусто

если длина название == 0 или больше максимум
    ошибки.добавить(Длина "название" должно быть в диапазоне 0 - максимум.)

если алиас не пусто
    если длина алиас == 0 или больше максимум
        ошибки.добавить(Длина "алиас" должно быть в диапазоне 0 - максимум.)
    если sql.наличие по алиас(алиас)    //При это есть алиас не задано, его сначала нужно создать
        ошибки.добавить(Алиас должно быть уникально.)
иначе
    алиас = генератор алиасов.генерировать()

ошибки = коллекция
валидатор.проверить на длину(данные.название, ошибки)
валидатор.проверить на длину(данные.алиас, ошибки)
валидатор.проверить на уникальность(таблица, столбец, данные.алиас, ошибки)

если есть ошибки
    вернуть строитель запросов
        .добавить(ошибки)
        .создать(запрос)

Фабрика алиасов
    генерация на основе названия(название, алиас)
