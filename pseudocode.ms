//----------------------------------------------------------------
// добавление/удаление позиции из рецепта
//----------------------------------------------------------------

ид рецепта = 10
ид позиции = 20

удалить позицию(ид рецепта, ид позиции)
    рецепт = бд.найти(рецепты, ид рецепта)
    если рецепт главный
        //позиция = бд.найти(позиции, ид позиции)
        бд.удалить(позиции, ид позиции)
    //или
    рецепт = бд.найти(рецепты, ид рецепта, главный)
    если рецепт
        бд.удалить(позиции, ид позиции)

ооп
класс Рецепт
    рецепт(данные)
        //...
    удалить позицию(ид позиции)
        если !можно редактировать()
            вернуть 0
        иначе
            _позиции.удалить(ид позиции)    //допустим тут доступ по ид
    можно редактировать(): bool

рецепт = Рецепт([
    42,
    Плов,
    [
        вода: 2000,
        рис: 1000,
        мясо: 1000,
        морковка: 1000,
        соль: 10,
        //...
    ]
])

рецепт.удалить(вода, 100)           //меньше воды
рецепт.добавить(черный перец, 1)    //тестируем сушеный чеснок
рецепт.добавить(сушеный чесно, 10)  //тестируем сушеный чеснок
рецепт.добавить(кориандр, 10)       //тестируем сушеный чеснок
/*
    Получается если делать всё на сервере в одном запросе от пользователя, то надо все операции фиксировать. Точнее получить все записи. Сделать действие. Затем в конце вызвать flush/update/save и выполнить:
    insert
    update
    delete

    insert если позиция новая
    delete если вес позиции <= 0
    update в остальных случаях

    Но при этом от пользователя проходит весь измененный список позиций сразу как с простой html формой + обработка в post как раньше. Что делал пользователь на клиенте не известно. Нужно просто обработать список и выполнить insert/update/create. И это не измененные данные, а полностью новые. Методы add/remove не нужны.
    Либо можно загрузить рецепт и позиции из бд на запрос пользователя. Методов add/remove не будет, а только set/update (по идеи это сеттеры). Следующая логика такая же: insert/delete/update.
*/

/*
    Вариант с api.

    Есть отдельные методы:

    добавить позицию(ид рецепта, ид продукта, вес)
    удалить позицию(ид рецепта, ид позиции)
    обновить позицию(ид рецепта, ид позиции, новый вес)

    //### вариант вообще без позиций ###
    /*
        т.е. как в игре. Программа(сервер)/класс/объект сами разберутся что делать. И никаких recipe_version_positions и кучи таблиц со связями наружу не показывается.
    */
    добавить продукт(ид рецепта, ид продукта, вес)
    удалить продукт(ид рецепта, ид продукта, вес)       //если итоговый вес <= 0 продукт полностью удаляется из рецепта
    полностью удалить продукт(ид рецепта, ид продкута)  //отдельный метод, чтобы не спутать. А в остальных обязательно нужно положительное число указывать.
    //идеи методов
    добавить продукт по весу другого продукта(ид рецепта, ид добавляемого продукта, ид имеющегося продукта, пропорция)
    обновить продукт по весу другого продукта(ид рецепта, ид требуемого продукта, ид имеющегося продукта, пропорция)
*/

//----------------------------------------------------------------
// Проверка возможности редактирования рецепта.
//----------------------------------------------------------------
Варианты.
1. Сделать отдельный запрос на поиск рецепта и обработать до позиции.
!2. Добавить в поиск позиции join, а в метод аргумент is_main/editable.
-> Неправильно. Определить наличие рецепта так невозможно.
-- Сделать метод только для поиска редактируемой позиции.
3. Класс Recipe/RecipeService, который сам решит можно ли редактировать рецепт или нет. Но при этом нужно отдельно вне класса делать связь с sql.
В 1ом варианте логика одна и может пригодиться еще в нескольких места, а в случае с джоином логику придется писать каждый раз новыю.

//----------------------------------------------------------------
// Валидация.
//----------------------------------------------------------------

данные =
    название: строка
    алиас: строка или пусто
    сорт: число или пусто

если длина название == 0 или больше максимум
    ошибки.добавить(Длина "название" должно быть в диапазоне 0 - максимум.)

если алиас не пусто
    если длина алиас == 0 или больше максимум
        ошибки.добавить(Длина "алиас" должно быть в диапазоне 0 - максимум.)
    если sql.наличие по алиас(алиас)    //При это есть алиас не задано, его сначала нужно создать
        ошибки.добавить(Алиас должно быть уникально.)
иначе
    алиас = генератор алиасов.генерировать()

ошибки = коллекция
валидатор.проверить на длину(данные.название, ошибки)
валидатор.проверить на длину(данные.алиас, ошибки)
валидатор.проверить на уникальность(таблица, столбец, данные.алиас, ошибки)

если есть ошибки
    вернуть строитель запросов
        .добавить(ошибки)
        .создать(запрос)

Фабрика алиасов
    генерация на основе названия(название, алиас)


//----------------------------------------------------------------
// Система прав.
//----------------------------------------------------------------
Варианты по "привязки":
1. На каждый объект. В том числе commits, head и тд.
2. Только на верхний (dish).

В 1ом варианте проверка прав доступа будет заключаться в получении dish на каждый объект снизу и проверка прав доступа на него. Нужно либо сделать n запросов или джоинов в 1ом запросе.
Во 2ом доступ проверяется на каждый объект в отдельности. Достаточно проверить user_id с ид пользователя и всё (или сделать запрос с условием по user_id).

Можно сделать вариант с универсальной таблицей, где таблицы с данными будет Контентом и правилами доступа к данному контенту. Можно задействовать стороннюю библиотеку на основе ролей.

Действия:
quality.create - только админ
quality.update - только админ
quality.delete - только админ

reference_product.create - только админ
reference_product.update - только админ
reference_product.delete - только админ

dish.create - все
dish.update - только свои
dish.delete - только свои

dish_version.create - все
    dish.create_dish_version - только в свой dish
dish_version.update - только свои
dish_version.delete - только свои

recipe.create - все //отдельного действия может не быть, рецепт добавляется только в версию
    dish_version.create_recipe - только в свой DishVersion
recipe.delete - только свои   //вот тут не понятно... от куда удалять
//Всё ниже происходит с рецептом.
recipe.add_product - только свои
recipe.remove_product - только свои
recipe.commit - только свои
recipe.create_branch - только свои

//----------------------------------------------------------------
// Работа с данным + ооп.
//----------------------------------------------------------------
Создать блюдо
Удалить блюдо

Блюдо
    Добавить версию
    Удалить версию

Версия блюда
    Добавить рецепт
    Удалить рецепт

Рецепт
    Добавить продукт
    Удалить продукт
    Коммит
    Создать ветку

----

DishService
    добавить версию(название)
    удалить версию(ид)

DishVersionService
    добавить рецепт(название)
    удалить рецепт(ид)

//----------------------------------------------------------------
// Типы связей между объектами/сущностями.
//----------------------------------------------------------------
- Объекты способные существовать сами по себе. Агрегация. Dish, DishVersion. Но DishVersion добавляется в Dish->addDishVersion(): DishVersion. Получается возвращается объект, но что внутри всё остается скрытым... Самим DishVersion можно управлять отдельно? Туда добавляются рецепты. Как удалить? Планировалось через dish->removeDishVersion(dishVersionID).
    Важно, что для всей остальной программы может не быть RecipePosition, а только объект ключ-значение вида referenceProductID => weight. Таким образом можно изменять класс как угодно.
- Объекты не способные существовать сами по себе. Композиция. Head, RecipePosition/CommitRecipePosition также могут не существать в виде классов, а скрыты в Recipe и доступные для управления через addProduct(productID, weight).
- Объекты или данные, для которых нет вообще объектов, но есть записи в бд. Например группы пользователей.
- "Сначала объект". Когда сначала делаются все объекты и логика. А потом уже к ним подключается связь с бд. Тот же User проще делать без учета структуры бд.

//----------------------------------------------------------------
// Сериалилация + паттерн стратегия.
//----------------------------------------------------------------

Блюдо
    ид
    название
    алиас
    ид качества
    ид пользователя

    //тут или рефлексия
    сериализация (сериализатор)
        сериализатор.записать(ид, значение)
        сериализатор.записать(название, значение)
        сериализатор.записать(алиас, значение)
        сериализатор.записать(ид качества, значение)
        сериализатор.записать(ид пользователя, значение)

api:
блюдо
    ид
    название
    алиас
    объект качества


СериализаторБлюда
    сериализаторКачества

    СериализаторБлюда(доступные поля)
    записать(поле, значение)
        проверка на доступность поля
    build(): array
        качество = qualityManager->findOne(this.ид качества)
        качество.сериализация(сериализаторКачества)

        вернуть [
            ид = this.ид,
            название = this.название,
            алиас = this.алиас,
            качество = сериализаторКачества.build(),
        ]

СериализаторКачества
    СериализаторКачества(доступные поля)
    записать(поле, значение)
    build(): array
        вернуть [
            ид = this.ид,
            название = this.название,
            алиас = this.алиас,
        ]

//----------------------------------------------------------------
// React получение ключа, формы регистрации.
//----------------------------------------------------------------
const [apiKey, setApiKey] = useState();

если не ключ получен
    форма регистрации
        нужно в каком то месте вызвать изменение состоания setApiKey
иначе
    основные компоненты